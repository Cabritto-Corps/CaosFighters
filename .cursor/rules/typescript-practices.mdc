---
alwaysApply: true
---
# Práticas TypeScript - Jogo de Batalha por Turnos

## Tipos e Interfaces

### Definição de Entidades do Jogo
- Sempre defina interfaces para entidades principais: `Character`, `Attack`, `Battle`
- Use tipos específicos em vez de `any`
- Implemente validação de tipos em runtime quando necessário

```typescript
interface Character {
  id: string;
  name: string;
  health: number;
  attacks: Attack[];
  // Sempre 4 ataques por personagem
}

interface Attack {
  id: string;
  name: string;
  damage: number;
  description: string;
  type: AttackType;
}
```

### Práticas de Código

#### Imports e Exports
- Use imports relativos para módulos do mesmo nível
- Use imports absolutos do barrel exports ([backend/domain/entities/index.ts](mdc:backend/domain/entities/index.ts))
- Mantenha imports organizados: externos primeiro, depois internos

#### Funções e Métodos
- Sempre tipagem explícita para parâmetros e retornos
- Use arrow functions para callbacks e funções pequenas
- Prefira função nomeada para métodos principais

```typescript
// BOM
const calculateDamage = (attack: Attack, character: Character): number => {
  return attack.damage * character.multiplier;
};

// EVITE
function calculateDamage(attack, character) {
  return attack.damage * character.multiplier;
}
```

#### Error Handling
- Use classes de erro específicas para domínio do jogo
- Implemente try-catch para operações assíncronas
- Valide inputs de usuário com tipos guards

```typescript
class BattleError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'BattleError';
  }
}
```

#### Async/Await
- Sempre use async/await em vez de Promises
- Implemente timeout para operações de rede
- Use Promise.all() para operações paralelas quando possível